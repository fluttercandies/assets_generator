import 'dart:io';

import 'package:build_runner_core/build_runner_core.dart';
import 'package:mime/mime.dart';
import 'package:path/path.dart' as p;

import '../args.dart';

const String headerFormatOff = '// dart format off';
const String headerLicense = '''// coverage:ignore-file
// ignore_for_file: constant_identifier_names
//
// GENERATED CODE - DO NOT MODIFY MANUALLY
// **************************************************************************
// Auto generated by https://github.com/fluttercandies/assets_generator
// **************************************************************************

''';

String get classDeclare => 'abstract final class {0} {';

String get classDeclareFooter => '}\n';

String get constsArray => '''
final List<String> {0} = <String>[
{1}];
''';

const String previewTemplate1 = '''/// {@template assets_generator.{0}.preview}
/// ![]({1})
/// {@endtemplate}

''';

const String previewTemplate = '''/// {@macro assets_generator.{0}.preview}
''';

const String mockClass = '''
// ignore_for_file: camel_case_types, unused_element, dangling_library_doc_comments, eol_at_end_of_file
class _ {}''';

class Template {
  Template(
    this.assets,
    this.packageGraph,
    this.rule,
    this.class1,
    this.constIgnore,
    this.constArray,
    this.package,
    this.useKeyName,
    this.classPrefix,
    this.rootPackageName,
  );

  final PackageNode? packageGraph;
  final List<String> assets;
  final Rule? rule;
  final Class? class1;
  final RegExp? constIgnore;
  final bool? constArray;
  final bool package;
  final bool useKeyName;
  final bool classPrefix;
  final String? rootPackageName;

  Future<String> generateFile(
    Map<String, String> miss,
    File previewFile,
  ) async {
    final StringBuffer sb = StringBuffer();
    sb.write(headerLicense);

    final StringBuffer arraySb = StringBuffer();

    final String className = class1!.go(
      'ucc',
      classPrefix ? packageGraph!.name : '',
    )!;

    sb.writeln(classDeclare.replaceAll('{0}', className));

    // Determine if current package is root: use rootPackageName if provided,
    // otherwise fall back to packageGraph.isRoot
    final bool isRoot = rootPackageName != null
        ? packageGraph!.name == rootPackageName
        : packageGraph!.isRoot;

    if ((!isRoot || package) && !useKeyName) {
      sb.writeln("  static const String package = '${packageGraph!.name}';");
    }

    final StringBuffer previewImageSb = StringBuffer();
    for (final String asset in assets) {
      if (constIgnore != null && constIgnore!.hasMatch(asset)) {
        continue;
      }
      final String filedName = _formatFiledName(asset);
      String filePath = asset;
      if (miss.containsKey(asset)) {
        filePath = miss[asset]!;
      }

      final String? mimeType = lookupMimeType(asset);
      final bool isImage = mimeType != null && mimeType.startsWith('image/');
      if (isImage) {
        // filePath uses POSIX-style separators in assets list; split and join
        // with platform-native separators so preview paths are correct on
        // Windows (\) and mac/Linux (/).
        final List<String> segments = filePath.split('/');
        final String localPath =
            p.joinAll(<String>[packageGraph!.path, ...segments]);

        previewImageSb.write(
          previewTemplate1
              .replaceAll('{0}', filedName)
              .replaceAll('{1}', localPath),
        );
      }

      String comment = '';
      if (isImage) {
        comment = previewTemplate.replaceAll('{0}', filedName);
      }

      // const value should be the generated path when useKeyName flag is set
      if (comment.isNotEmpty) {
        sb.write('\n  $comment');
      }
      sb.write(
        formatFiled(
          asset,
          (!isRoot || package) && useKeyName
              ? p.posix.join('packages', packageGraph!.name, asset)
              : asset,
        ),
      );

      if (constArray!) {
        if (comment.isNotEmpty) {
          arraySb.write('\n  $comment');
        }
        arraySb.write('  $className.$filedName,\n');
      }
    }

    sb.write(classDeclareFooter);

    if (arraySb.isNotEmpty) {
      sb.writeln();
      sb.write(
        constsArray
            .replaceAll(
              '{0}',
              '${class1!.go('lcc', classPrefix ? packageGraph!.name : '')!}Array',
            )
            .replaceAll('{1}', arraySb.toString()),
      );
    }

    if (previewImageSb.isNotEmpty) {
      final String content = headerLicense + previewImageSb.toString() + mockClass;
      previewFile.createSync(recursive: true);
      previewFile.writeAsStringSync(content);
    }

    return sb.toString();
  }

  String formatFiled(String asset, String path) {
    return '''  static const String ${_formatFiledName(asset)} = '$path';\n''';
  }

  String _formatFiledName(String path) {
    path = path
        .replaceAll('/', '_')
        .replaceAll('.', '_')
        .replaceAll(' ', '_')
        .replaceAll('-', '_')
        .replaceAll('@', '_AT_');
    return rule!.go(path);
  }
}
